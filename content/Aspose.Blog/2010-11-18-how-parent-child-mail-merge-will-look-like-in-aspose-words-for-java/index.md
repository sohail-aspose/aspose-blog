---
title: 'How parent/child mail merge will look like in Aspose.Words for Java'
date: Thu, 18 Nov 2010 22:59:00 +0000
draft: false
url: /2010/11/18/how-parent-child-mail-merge-will-look-like-in-aspose-words-for-java/
author: Romank
summary: ''
tags: []
categories: ['Aspose.Words Product Family']
---

Yes, parent/child (nested mail merge regions) is one of those highly demanded features that is available in Aspose.Words for .NET and not yet available in Aspose.Words for Java. And yes, this feature is going to be available for Java very soon, when our autoporting project is complete.

BTW, there are only 16 files remain to be made autoportable.

TodayÂ a small technical article that describes challenges and solutions we came across when making the Aspose.Words MailMerge autoportable to Java.

## Overview

To run a mail merge in Aspose.Words requires a "mail merge data source". Mail merge data sources in Aspose.Words are completely abstracted via the **IMailMergeDataSource** and **IMailMergeDataSourceRoot** interfaces. The abstraction of mail merge data sources via interfaces allows the user to feed **any data** on **any platform** into a document template during mail merge. For example, the user can implement a mail merge data source to retrieve data from an XML document or from a business object or a collection of objects.

Although implementing mail merge data sources for Aspose.Words is easy, most of the users don't need this flexibility. Most of the users have their data in a "standard" database access library on their platform. Therefore Aspose.Words implements the "standard" mail merge data sources and allows the user to use them seamlessly. On .NET the database access technoligy is ADO.NET and Aspose.Words allows to mail merge from **DataTable**, **DataSet** and other objects (more info below). On Java the database access technology is JDBC and Aspose.Words allows to mail merge from **ResultSet** objects.

Obviously, ADO.NET and JDBC both are platform-specific technologies and we cannot expect to automatically port code that accesses ADO.NET objects to Java. But nevertherless, I wanted to make sure that as much code is autoportable and only the thin layer of platform-specific details is manually coded. At the same time, the public API should be smooth on both platforms.

## Problems and Solutions

<figure class="wp-block-table"><table class=""><tbody><tr><th>.NET</th><th>Java</th><th>Problem and Solution</th></tr><tr><td>**DataTable</strong> has <strong>TableName</strong></td><td><strong>ResultSet</strong> does not have a table name</td><td>ADO.NET <strong>DataTable</strong> roughly corresponds to <strong>ResultSet</strong> in Java. The problem is that during mail merge Aspose.Words needs to know the table name. It uses the table name to match with the mail merge region in the template document. E.g. the "Orders" table will be used to populate the "Orders" mail merge region. In .NET, the table name is avaialble in <strong>DataTable.TableName</strong>, but in Java, the table name is not easily available.<br>In some cases the table name in Java can be obtained from ResultSetMetadata, but not always.<br><br>In earlier version of Aspose.Words for Java I think we provided a method that accepted two parameters ResultSet and String (instead of one parameter DataTable on .NET). Such difference in signature is not good for autoporting and I decided to make it better this time.<br><br>I introduced the new public <strong>com.aspose.words.DataTable</strong> class that is basically a tuple, it just stores a ResultSet and a table name inside itself. So the user will need to pass <strong>com.aspose.words.DataTable</strong> instead of plain <strong>ResultSet</strong> on Java and thus the user will be forced to make sure he specifies the table name and this solved many autoporting issues at the same time.</td></tr><tr><td><strong>DataSet</strong></td><td>Not available</td><td>ADO.NET <strong>DataSet</strong> can contain many tables and relationships between them. Aspose.Words accepts a <strong>DataSet</strong> object for mail merge operations that populate multiple mail merge regions in one pass. This includes the highly popular nested mail merges.<br><br>In earlier version of Aspose.Words for Java we provided a public class <strong>ResultSetHashMap</strong>, which was actually a map of string table name into a <strong>ResultSet</strong> object. This was enough for mail merge operations with multiple mail merge regions, but was not enough for nested mail merges because nested mail merges need data relations described.<br><br>I introduced the new public <strong>com.aspose.words.DataSet</strong> class that mimics the bare minimum of the <strong>System.Data.DataSet</strong> class needed for nested mail merge to work on Java and also helps to make code autoportable. The user will need to create a <strong>com.aspose.words.DataSet</strong> object, add <strong>com.aspose.words.DataTable</strong> objects to it and also add <strong>com.aspose.words.DataRelation</strong> objects.</td></tr><tr><td><strong>DataRelation</strong></td><td>Not available</td><td>This is related to the above. ADO.NET <strong>DataSet</strong> has a collection of <strong>DataRelation</strong> objects the describe the parent-child relationships between the tables in the dataset. The Aspose.Words "standard mail merge data source" implementation uses DataRelations to navigate from parent to child tables and to select the child rows. In other words the parent-child structure of the document template and the parent-child links in the DataSet need to match for a nested mail merge to be successful.<br><br>There was no DataSet and no DataRelation on Java, so I created these classes as public classes in the Aspose.Words API for Java. They mimic the ADO.NET classes, but implement the bare minimum needed for Aspose.Words mail merge to work.</td></tr><tr><td><strong>DataRow.GetChildRows</strong></td><td>Not available</td><td>During nested mail merge Aspose.Words needs to select child records for the current parent record. For example select all order items for the current order. This is easy to do in ADO.NET using the <strong>DataRow.GetChildRows(DataRelation childRelation)</strong>. There is nothing like that on Java.<br><br>At first I tried to use FilteredRowSet to apply a filter over a table that will select the child rows, but then figured that FilteredRowSet is only available on Java 1.5 or higher. This is not good since we target 1.4 too. I simply ended up implementing our own filtering inside the Java implementation of the mail merge data source.<br><br>As a result, two files are manually implemented in Java:<br><strong>MailMergeDataSourceDataTable</strong> - This iterates over all records in a ResultSet (used for a root table or for non nested mail merges)<br><strong>MailMergeDataSourceDataRelation</strong> - This iterates over filtered records in a ResultSet (used for child tables in a nested mail merge).</td></tr><tr><td>Unit tests,<br>ADO.NET <strong>Connection</strong> etc</td><td>JDBC Connection etc</td><td>Hidden in the platform specific <strong>TestMailMergePal</strong> class, see below.</td></tr><tr><td>Unit tests, programmatic creation of disconnected <strong>DataSet</strong>, <strong>DataTable</strong></td><td> </td><td>Store tests data in CSV files. Implemented loading of CSV into <strong>System.Data.DataTable</strong> and <strong>com.aspose.words.DataTable</strong> (e.g. <strong>ResultSet</strong>) in the platform specific <strong>TestMailMergePal** class, see below.</td></tr></tbody></table></figure>

## Aspose.Words MailMerge - .NET to Java public API mappings

<figure class="wp-block-table"><table class=""><tbody><tr><th>.NET</th><th>Java</th><th>Comment</th></tr><tr><td>Execute(IMailMergeDataSource)</td><td>execute(IMailMergeDataSource)</td><td>Ok</td></tr><tr><td>Execute(string[] fieldNames, object[] values)</td><td>execute(String[], Object[])</td><td>Ok</td></tr><tr><td>Execute(System.Data.DataTable)</td><td>execute(com.aspose.words.DataTable)</td><td>Ok. On Java, instead of **System.Data.DataTable</strong>, the user needs to use <strong>com.aspose.words.DataTable</strong> that contains <strong>java.sql.ResultSet</strong>.</td></tr><tr><td>ExecuteADO(object recordset)</td><td>N/A</td><td>COM and ADO is not applicable on Java.</td></tr><tr><td>Execute(IDataReader)</td><td>N/A</td><td>ADO.NET data reader, not applicable on Java.</td></tr><tr><td>Execute(DataView)</td><td>N/A</td><td>ADO.NET data view, not applicable on Java.</td></tr><tr><td>Execute(DataRow)</td><td>N/A</td><td>ADO.NET data row, not applicable on Java.</td></tr><tr><td>ExecuteWithRegions(IMailMergeDataSource)</td><td>executeWithRegions(IMailMergeDataSource)</td><td>Ok</td></tr><tr><td>ExecuteWithRegions(IMailMergeDataSourceRoot)</td><td>executeWithRegions(IMailMergeDataSourceRoot)</td><td>Ok</td></tr><tr><td>ExecuteWithRegions(System.Data.DataSet)</td><td>executeWithRegions(com.aspose.words.DataSet)</td><td>Ok. On Java, the user needs to create <strong>com.aspose.words.DataSet</strong> and add <strong>com.aspose.words.DataTable</strong> and add <strong>com.aspose.words.DataRelation** objects to describe the data and relationships between the tables.</td></tr><tr><td>ExecuteWithRegions(System.Data.DataTable)</td><td>executeWithRegions(com.aspose.words.DataTable)</td><td>Ok</td></tr><tr><td>ExecuteWithRegionsADO(object recordset)</td><td>N/A</td><td>COM ADO not applicable on Java.</td></tr><tr><td>ExecuteWithRegions(DataView)</td><td>N/A</td><td>ADO.NET data view not applicable on Java.</td></tr><tr><td>ExecuteWithRegions(IDataReader, string tableName)</td><td>N/A</td><td>ADO.NET data reader not applicable on Java.</td></tr></tbody></table></figure>








